# Sesion Guardada

- Fecha/hora UTC: 2026-02-19 01:23:53Z
- Fecha/hora local: 2026-02-18 22:23:53 -03
- Contexto: Integracion de Postgres real (DB `v360`) al demo `vertice360-orquestador` en backend Litestar.

## Objetivo de la sesion
Integrar DB real `v360` usando Python directo (psycopg), sin tocar la logica existente de messaging/workflow salvo agregar endpoints nuevos bajo `/api/demo/...`.

## Trabajo realizado

### A) Configuracion global (`globalVar.py`)
- Se agrego lectura de `DB_PG_V360_URL`.
- Se agrego `ALLOW_FALLBACK_V360_DB` (default `false`).
- Se agrego validacion minima:
  - esquema Postgres (`postgresql`, `postgresql+psycopg`, `postgres`)
  - DB objetivo `v360` (path `/v360` o `dbname=v360`)
- Se agrego helper `get_v360_db_url()` con fallback explicito a `DB_URL` solo si `ALLOW_FALLBACK_V360_DB=true`.
- Se agregaron warnings y visibilidad en `boot_log()`.

### B) Nuevo modulo backend
Creado `modules/vertice360_orquestador_demo/`:
- `__init__.py`
- `db.py` (conexion/transaccion, pool opcional si `psycopg_pool` esta disponible)
- `repo.py` (queries SQL para bootstrap, dashboard, ingest, visitas, supervisor)
- `services.py` (logica de negocio)
- `schemas.py` (request models)

Reglas aplicadas:
- Normalizacion `phone_e164` a prefijo `+549...` cuando llega sin `+`.
- Tickets por `conversation_id` (alineado a `UNIQUE (conversation_id)` en DB).
- Mensajes con `direction in/out` + `actor` enum valido.
- Eventos siempre con `correlation_id = ticket_id`.
- Stage consistente:
  - propose/reschedule -> `Esperando confirmaciÃ³n`
  - confirm -> `Visita confirmada`

### C) Router demo
Creado `routes/demo_vertice360_orquestador.py` con:
- `GET /api/demo/vertice360-orquestador/bootstrap`
- `GET /api/demo/vertice360-orquestador/dashboard?cliente=...`
- `POST /api/demo/vertice360-orquestador/ingest_message`
- `POST /api/demo/vertice360-orquestador/visit/propose`
- `POST /api/demo/vertice360-orquestador/visit/confirm`
- `POST /api/demo/vertice360-orquestador/visit/reschedule`
- `POST /api/demo/vertice360-orquestador/supervisor/send`

### D) Wiring demo
- Registrado router en `ls_iMotorSoft_Srv01_demo.py`.
- No se toco entrypoint prod.

### E) Tests
Creado `tests/test_vertice360_orquestador_demo_smoke.py` con casos:
1. bootstrap retorna seeds esperados (3 projects, 3 marketing_assets, 2 users)
2. ingest crea lead+conversation+ticket+message+event
3. dashboard muestra ticket con `last_message_snippet`
4. propose + confirm actualiza stage y `visit_scheduled_at`
5. supervisor_send agrega message y event

### F) Documentacion
- `README.md`: nota de configuracion para `DB_PG_V360_URL` y fallback.
- Nuevo doc: `docs/demo_vertice360_orquestador_db.md`.

## Verificacion DB real durante la sesion
Se inspecciono `v360` (solo lectura) y se confirmo:
- Tablas: `projects`, `marketing_assets`, `users`, `leads`, `conversations`, `tickets`, `messages`, `events`, `visit_proposals`, `visit_confirmations`.
- Enums: `lead_stage`, `actor_role`, `visit_proposal_status`, `channel_type`.
- Seeds: `projects=3`, `marketing_assets=3`, `users=2`.

## Archivos modificados/creados
- Modificados:
  - `README.md`
  - `globalVar.py`
  - `ls_iMotorSoft_Srv01_demo.py`
  - `pyproject.toml`
- Nuevos:
  - `docs/demo_vertice360_orquestador_db.md`
  - `modules/vertice360_orquestador_demo/__init__.py`
  - `modules/vertice360_orquestador_demo/db.py`
  - `modules/vertice360_orquestador_demo/repo.py`
  - `modules/vertice360_orquestador_demo/schemas.py`
  - `modules/vertice360_orquestador_demo/services.py`
  - `routes/demo_vertice360_orquestador.py`
  - `tests/test_vertice360_orquestador_demo_smoke.py`

## Estado de ejecucion de tests en esta maquina
- `pytest -q tests/test_gupshup_globalvar_defaults.py tests/test_vertice360_orquestador_demo_smoke.py`
  - Resultado: `1 passed, 5 skipped`
- `pytest -q tests/test_demo_whatsapp_unified_send.py::test_unified_send_meta_success_shape`
  - Resultado: `1 passed`
- `pytest -q tests/test_vertice360_ai_workflow_smoke.py::test_multi_intent_price_location`
  - Resultado: `1 passed`

Nota: los smoke de orquestador quedaron en skip en este entorno por disponibilidad efectiva de driver/conectividad runtime; el codigo queda listo para correrlos con DB/driver habilitados.
